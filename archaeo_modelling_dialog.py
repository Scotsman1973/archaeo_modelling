# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SitePredictionDialog
                                 A QGIS plugin
 This plugin aids researchers in modelling archaeological sites/areas
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-11-20
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Andrew Prentice
        email                : aaprentice@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from dataclasses import fields
from distutils.command.check import check
from rasterio import plot as rasterplot
import matplotlib.pyplot as plt
import matplotlib as mpl
import geopandas as gpd
import pandas as pd
import rasterio
from rasterio.plot import plotting_extent
from win32api import GetSystemMetrics
import elapid as ela #this package implements the maxent algorithm
from sklearn import metrics
import warnings
import glob
import os

from qgis.core import (QgsVectorLayer, QgsRasterLayer, QgsField, QgsRasterBandStats)
from qgis.gui import QgsFileWidget
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt.QtWidgets import QFileDialog, QListWidgetItem, QTableWidget

import processing

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'archaeo_modelling_dialog_base.ui'))


class SitePredictionDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(SitePredictionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        #basic model inputs and placeholder text
        self.Geo_Area_LEdit.setPlaceholderText('Geographic region')
        self.geoArea_PButton.clicked.connect(self.getGeoAreaFile)

        self.ActivityA_LEdit.setPlaceholderText('Activity area')
        self.ActivityA_PButton.clicked.connect(self.getActAreaFile)
        
        self.Site_L_Edit.setPlaceholderText('Archaeological sites')
        self.Sites_P_Button.clicked.connect(self.getSiteFile)
        self.Site_L_Edit.valueChanged.connect(self.addSiteFields)
        self.siteFieldCBox.activated.connect(self.addAttributes)

##################################################################################
#geospatial inputs
        self.DefaultLineEdit1.setPlaceholderText('Geospatial vector data')
        self.default_lf_PButton1.clicked.connect(self.getFile_1)
        self.DefaultLineEdit1.valueChanged.connect(self.addFields_1)
        self.Default_CBox1.activated.connect(self.popTextBox1)

        self.weights_PButton.clicked.connect(self.getValues1)

############################################################################################
#contour inputs

        self.contourFileLEdit.setPlaceholderText('Contour vector data')
        self.contourPButton.clicked.connect(self.getContourFile)
        self.contourFileLEdit.valueChanged.connect(self.addFieldsContours)
        
        self.processContourPButton.clicked.connect(self.RasterizeContour2memory)

#######################################################################
#site types

        self.createModel_PButton.clicked.connect(self.createModel)
#################################################################
#folder destination
        self.outputPathFileWidget.setStorageMode(QgsFileWidget.StorageMode.GetDirectory)
        self.outputPathFileWidget.fileChanged.connect(self.outputPath)
#############################################################################################
#clear inputs button
        self.clearInputsPButton.clicked.connect(self.clearInputs)

#################################################################
#set default values for contour spinboxes

        self.elevationSpinBox.setValue(5)
        self.slopeSpinBox.setValue(5)

        #####################################
        #cancel button
        self.cancelDefault_PButton.clicked.connect(self.cancelGUI)

    def getSiteFile(self):
        file_name = QFileDialog.getOpenFileName(None, 'Select file', '', filter='*.shp; *.gpkg; *.tab')
        if file_name:
            site_file_name = file_name[0]
            self.Site_L_Edit.setText(site_file_name)
        return site_file_name
    
    def getGeoAreaFile(self):
        file_name = QFileDialog.getOpenFileName(None, 'Select file', '', filter='*.shp; *.gpkg; *.tab')
        if file_name:
            geo_file_name = file_name[0]
            self.Geo_Area_LEdit.setText(geo_file_name)
        return geo_file_name
    
    def getActAreaFile(self):
        file_name = QFileDialog.getOpenFileName(None, 'Select file', '', filter='*.shp; *.gpkg; *.tab')
        if file_name:
            aa_file_name = file_name[0]
            self.ActivityA_LEdit.setText(aa_file_name)
        return aa_file_name

    def addSiteFields(self):
        self.siteFieldCBox.clear()
        site_file = self.Site_L_Edit.text()
        v_site_file = QgsVectorLayer(str(site_file), "Site layer", "ogr")
        fields = v_site_file.fields()
        for field in fields:
            self.siteFieldCBox.addItem(str(field.name()))

    def addAttributes(self):
        self.siteTypeCBox.clear()
        current_file = self.Site_L_Edit.text()
        current_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        current_field = self.siteFieldCBox.currentText()
        fields = current_file.fields()
        idx = fields.indexFromName(str(current_field))
        list_items = current_file.uniqueValues(idx)
        list1 = [f[idx] for f in current_file.getFeatures()]
        for list_item in list_items:
            item_count = list1.count(str(list_item))
            if item_count > 1:
                self.siteTypeCBox.addItem(str(list_item))
        return list_items
    
    def getSiteType(self):
        sites4model = []
        chosen = self.siteTypeCBox.checkedItems()
        for i in range(len(chosen)):
            sites4model.append(str(chosen[i]))
        return sites4model
    ############################
    def outputPath(self):
        path = self.outputPathFileWidget.filePath()
        print(path)
        return
###############################################
    def cancelGUI(self):
        self.close()
        return
############################################
#default input functions
    def getFile_1(self):
        file_name = QFileDialog.getOpenFileName(None, 'Select file', '', filter='*.shp; *.gpkg; *.tab')
        if file_name:
            file_name_1 = file_name[0]
            self.DefaultLineEdit1.setText(file_name_1)
        return file_name_1
    ##################################################
    def addFields_1(self):
        self.Default_CBox1.clear()
        site_file = self.DefaultLineEdit1.text()
        v_site_file = QgsVectorLayer(str(site_file), "Site layer", "ogr")
        fields = v_site_file.fields()
        for field in fields:
            self.Default_CBox1.addItem(str(field.name()))
    ############################################################

    def popTextBox1(self):
        RBaa_state = self.AAfeatures_RButton.isChecked()
        RBwPoints_state = self.AAwArtefact_RButton.isChecked()
        current_file = self.DefaultLineEdit1.text()
        current_vec_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        current_field = self.Default_CBox1.currentText()
        fields = current_vec_file.fields()
        idx = fields.indexFromName(str(current_field))
        list_items = current_vec_file.uniqueValues(idx)
        self.Custom_T_Widget.clear()
        self.Custom_T_Widget.setColumnCount(2)
        self.Custom_T_Widget.setHorizontalHeaderLabels(['Feature', 'Weight'])
        self.Custom_T_Widget.setRowCount(len(list_items))
        #populate the textbox with unique items
        if list_items:
            for row, li in enumerate(list_items):
                self.Custom_T_Widget.setItem(row, 0, QtWidgets.QTableWidgetItem( str(li) ) )#must be string
        #default weighting options
        if RBaa_state == True:
            self.fiveInAA()
        elif RBwPoints_state == True:
            self.pointInPolygon()
        else:
            pass
        return
    
    def pointInPolygon(self):
        AAfeaturesWsite = []
        list_landformWsite = []
        sites_text = self.Site_L_Edit.text()
        site_file = QgsVectorLayer(str(sites_text), "Site layer", "ogr")
        current_file = self.DefaultLineEdit1.text()
        v_site_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        current_field = self.Default_CBox1.currentText()
        fields = v_site_file.fields()
        idx = fields.indexFromName(str(current_field))
        list_items = v_site_file.uniqueValues(idx)
        #################################
        aa_file = self.ActivityA_LEdit.text()
        aa_vec_file = QgsVectorLayer(str(aa_file), "Site layer", "ogr")
        ######################################################
        actArea = processing.run("native:clip", {'INPUT':v_site_file,
                                        'OVERLAY':aa_vec_file,
                                        'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']

        for feature in actArea.getFeatures():
            feature_poly = feature.geometry() # this grabs the geometry of the zone
            
            for site in site_file.getFeatures():
                site_geom = site.geometry()
                if (site_geom is None):
                    continue
                if site_geom.within(feature_poly):
                    AAfeaturesWsite.append(feature)

        for featureW in AAfeaturesWsite:
            attr = featureW.attributes()
            landformWsite = attr[int(idx)]
            list_landformWsite.append(landformWsite)
        
        for row, li in enumerate(list_items):
            if str(li) in landformWsite:
                self.Custom_T_Widget.setItem(row, 1, QtWidgets.QTableWidgetItem(str(5)) )
            else:
                self.Custom_T_Widget.setItem(row, 1, QtWidgets.QTableWidgetItem(str(3)) )

        return

    def fiveInAA(self):
        current_file = self.DefaultLineEdit1.text()
        v_site_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        current_field = self.Default_CBox1.currentText()
        fields = v_site_file.fields()
        idx = fields.indexFromName(str(current_field))
        list_items = v_site_file.uniqueValues(idx)
        #################################
        aa_file = self.ActivityA_LEdit.text()
        aa_vec_file = QgsVectorLayer(str(aa_file), "Site layer", "ogr")
        ######################################################
        lformInAA = processing.run("native:clip", {'INPUT':v_site_file,
                                        'OVERLAY':aa_vec_file,
                                        'OUTPUT':'TEMPORARY_OUTPUT'})
        clipped_fields = lformInAA['OUTPUT'].fields()#those fields within the activity area can be weighted differently
        clipped_idx = clipped_fields.indexFromName(str(current_field))
        AA_list_items = lformInAA['OUTPUT'].uniqueValues(clipped_idx)
        
        for row, li in enumerate(list_items):
            if str(li) in AA_list_items:
                self.Custom_T_Widget.setItem(row, 1, QtWidgets.QTableWidgetItem(str(5)) )
            else:
                self.Custom_T_Widget.setItem(row, 1, QtWidgets.QTableWidgetItem(str(3)) )
        return

    def getValues1(self):
        uniqueFeatures = []
        weightValues = []
        for row in range(self.Custom_T_Widget.rowCount()):
            it_w = self.Custom_T_Widget.item(row, 1)
            text_w = it_w.text() if it_w is not None else ""
            weightValues.append(text_w)
            #######################
            it_f = self.Custom_T_Widget.item(row, 0)
            text_f = it_f.text() if it_f is not None else ""
            uniqueFeatures.append(text_f)
        zippedValues = list(zip(uniqueFeatures, weightValues) )
        self.outputCSVweightings(zippedValues)
        self.amendAttrTable1(zippedValues)
        return zippedValues
    
    def outputCSVweightings(self, zippedValues):
        #get output path
        path = self.outputPathFileWidget.filePath()
        #get fielf name
        current_field = self.Default_CBox1.currentText()
        new_field_name = "lf_"+str(current_field[-4:-1])+"w"
        #create empty lists
        feature = []
        weight = []
        array = []
        index_values = []
        #unzip into two lists, in order to join again and create a csv
        for i in range(len(zippedValues)):
            (first,last) = zippedValues[i]
            feature.append(first)
            weight.append(last)
        for i in range(len(feature)):
            array.append([feature[i], weight[i]])
            index_values.append(i)
            columns_values = ['Landscape feature', 'Weight (1 - 9)']
            #create df
            df = pd.DataFrame(data=array, index=index_values, columns=columns_values)
            #dataframe tp csv, and save to path
            df.to_csv('{output_path}/{layer}_weights.csv'.format(output_path = path, layer = new_field_name))
        return
    
    def amendAttrTable1(self, zippedValues):
        current_file = self.DefaultLineEdit1.text()
        v_site_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        current_field = self.Default_CBox1.currentText()
        fields = v_site_file.fields()
        idx = fields.indexFromName(str(current_field))
        new_field_name = "lf_"+str(current_field[-4:-1])+"w"
        v_site_file.dataProvider().addAttributes([QgsField(str(new_field_name), QVariant.Double)]) # creates a new field
        v_site_file.updateFields()
        fields = v_site_file.fields()
        new_idx = fields.indexFromName(str(new_field_name))
        row = 0
        for feature in v_site_file.getFeatures():
            for i, uF in enumerate(zippedValues):
                if (feature[idx] == uF[0]):#unzip
                    weight = uF[1]
                else:
                    pass  
            v_site_file.startEditing() # start to edit the attribute table by adding weights to those polygons that match
            v_site_file.changeAttributeValue(row, int(new_idx), weight)
            v_site_file.commitChanges()
            row+=1
        #writin them into a file gets around a list problem I couldn't solve
        self.writeRaster2memory(new_field_name)
        return v_site_file
    
    def writeRaster2memory(self, new_field_name):
        #get output path
        path = self.outputPathFileWidget.filePath()
        #have to write individual rasters to memory otherwise list empties on each iteration
        #must vectorize the file path, not the new file name variable
        current_file = self.DefaultLineEdit1.text()
        v_site_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        #get the vector's EPSG code
        raster_crs = v_site_file.crs().authid()
        #get the layer's extent coordinates
        ext = v_site_file.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        #rasterize and save to memory with name specific to field rasterised
        output_tif = '{output_path}/new_{file_name}.tif'.format(output_path = path, file_name = new_field_name)
        vectorToRasterProcessing = processing.run("gdal:rasterize", {'INPUT': v_site_file,
                                          'FIELD':'{}'.format(new_field_name),
                                          'BURN':0,
                                          'USE_Z':False,
                                          'UNITS':0,
                                          'WIDTH':200,
                                          'HEIGHT':200,
                                          'EXTENT':'{xminimum},{xmaximum},{yminimum},{ymaximum} [{crs}]'.format(xminimum = xmin, xmaximum = xmax, yminimum = ymin, ymaximum = ymax, crs = raster_crs),
                                          'NODATA':0,
                                          'OPTIONS':'COMPRESS=PACKBITS',
                                          'DATA_TYPE':5,
                                          'INIT':None,
                                          'INVERT':False,
                                          'EXTRA':'',
                                          'OUTPUT': output_tif})
        return vectorToRasterProcessing
    ########################################################################

    def getContourFile(self):
        file_name = QFileDialog.getOpenFileName(None, 'Select file', '', filter='*.shp; *.gpkg; *.tab')
        if file_name:
            file_name_contour = file_name[0]
            self.contourFileLEdit.setText(file_name_contour)
        return file_name_contour
    
    ####################################################################
    def addFieldsContours(self):
        self.elevationFieldCBox.clear()
        contour_file = self.contourFileLEdit.text()
        v_contour_file = QgsVectorLayer(str(contour_file), "Site layer", "ogr")
        fields = v_contour_file.fields()
        for field in fields:
            self.elevationFieldCBox.addItem(str(field.name()))
        self.addAspects()


    def RasterizeContour2memory(self):
        #get output path
        path = self.outputPathFileWidget.filePath()
        #have to write individual rasters to memory otherwise list empties on each iteration
        #must vectorize the file path, not the new file name variable
        current_file = self.contourFileLEdit.text()
        v_contour_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        elevation_field = self.elevationFieldCBox.currentText()
        #get the vector's EPSG code
        vector_crs = v_contour_file.crs().authid()
        #get the layer's extent coordinates
        ext = v_contour_file.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        #create folder called temp inside the path chosen by user
        directory = 'temp'
        pathForFolder = os.path.join(path, directory)
        accessPermissions = 0o777#readable and writeable by all
        os.mkdir(pathForFolder, accessPermissions)
        #rasterize and save to memory with name specific to field rasterized
        output_tif = '{output_path}/temp/new_{file_name}.tif'.format(output_path = path, file_name = elevation_field)
        elevation_file_name = 'new_'+str(elevation_field)
        vectorToRasterProcessing = processing.run("gdal:rasterize", {'INPUT': v_contour_file,
                                          'FIELD':'{}'.format(elevation_field),
                                          'BURN':0,
                                          'USE_Z':False,
                                          'UNITS':0,
                                          'WIDTH':200,
                                          'HEIGHT':200,
                                          'EXTENT':'{xminimum},{xmaximum},{yminimum},{ymaximum} [{crs}]'.format(xminimum = xmin, xmaximum = xmax, yminimum = ymin, ymaximum = ymax, crs = vector_crs),
                                          'NODATA':0,
                                          'OPTIONS':'COMPRESS=PACKBITS',
                                          'DATA_TYPE':5,
                                          'INIT':None,
                                          'INVERT':False,
                                          'EXTRA':'',
                                          'OUTPUT': output_tif})
        
        contourRaster = QgsRasterLayer(output_tif, 'elev_raster')
        provider = contourRaster.dataProvider()

        elevation_stats = provider.bandStatistics(1, QgsRasterBandStats.All)
        elevation_max = elevation_stats.maximumValue
        elevation_min = elevation_stats.minimumValue
        elevation_range =  elevation_stats.range

        ###################################################################
        aa_file = self.ActivityA_LEdit.text()
        aa_vec_file = QgsVectorLayer(str(aa_file), "Site layer", "ogr")

        #get the AA layer's EPSG code
        vector_crs = aa_vec_file.crs().authid()
        #get the AA layer's extent coordinates
        ext = aa_vec_file.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()

        clip_to_AA = processing.run("gdal:cliprasterbyextent", {'INPUT': contourRaster,
                                                   'PROJWIN':'{xminimum},{xmaximum},{yminimum},{ymaximum} [{crs}]'.format(xminimum = xmin, xmaximum = xmax, yminimum = ymin, ymaximum = ymax, crs = vector_crs),
                                                   'OVERCRS':False,
                                                   'NODATA':None,
                                                   'OPTIONS':'COMPRESS=PACKBITS',
                                                   'DATA_TYPE':0,
                                                   'EXTRA':'',
                                                   'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
        
        AARaster = QgsRasterLayer(clip_to_AA, 'AAelev_raster')
        provider = AARaster.dataProvider()
        #get percent above and below from spinbox
        elev_Value = self.elevationSpinBox.value()
        #get stats from raster of the activity area
        AA_stats = provider.bandStatistics(1, QgsRasterBandStats.All)
        AA_elevation_min = AA_stats.minimumValue
        AA_elevation_max = AA_stats.maximumValue
        AA_elevation_range = AA_stats.range
        
        elev_percent_range = (elevation_range/100) * int(elev_Value)
        lower_value = AA_elevation_min - elev_percent_range
        upper_value = AA_elevation_max + elev_percent_range

        outputElevation_tif = '{output_path}/elevation.tif'.format(output_path = path)
        processing.run("qgis:rastercalculator", {'EXPRESSION':'IF(("{firstLayer}@1" > {lower}) AND ("{secondLayer}@1" < {upper}), 5, 3)'.format(firstLayer = elevation_file_name, lower = lower_value, secondLayer = elevation_file_name, upper = upper_value),
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = elevation_file_name)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': outputElevation_tif})
        
        if self.slopeCheckBox.isChecked():
            self.slopeFromElevation()
        aspects = self.aspectComboBox.checkedItems()
        if len(aspects) > 0:
            self.aspectFromElevation()
        else:
            pass
        return
        ###################################
    def slopeFromElevation(self):
        #get output path
        path = self.outputPathFileWidget.filePath()
        #this was the easiest, not necessarily the most efficient method
        #must vectorize the file path, not the new file name variable
        current_file = self.contourFileLEdit.text()
        v_contour_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        elevation_field = self.elevationFieldCBox.currentText()
        #get the vector's EPSG code
        vector_crs = v_contour_file.crs().authid()
        #get the layer's extent coordinates
        ext = v_contour_file.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        #rasterize and save to memory with name specific to field rasterized
        output_tif = '{output_path}/temp/new_{file_name}.tif'.format(output_path = path, file_name = elevation_field)
        vectorToRasterProcessing = processing.run("gdal:rasterize", {'INPUT': v_contour_file,
                                          'FIELD':'{}'.format(elevation_field),
                                          'BURN':0,
                                          'USE_Z':False,
                                          'UNITS':0,
                                          'WIDTH':200,
                                          'HEIGHT':200,
                                          'EXTENT':'{xminimum},{xmaximum},{yminimum},{ymaximum} [{crs}]'.format(xminimum = xmin, xmaximum = xmax, yminimum = ymin, ymaximum = ymax, crs = vector_crs),
                                          'NODATA':0,
                                          'OPTIONS':'COMPRESS=PACKBITS',
                                          'DATA_TYPE':5,
                                          'INIT':None,
                                          'INVERT':False,
                                          'EXTRA':'',
                                          'OUTPUT': output_tif})
        
        contourRaster = QgsRasterLayer(output_tif, 'elev_raster')

        output_tif = '{output_path}/temp/slope_{file_name}.tif'.format(output_path = path, file_name = elevation_field)
        elevation_file_name = 'slope_'+str(elevation_field)
        derivedSlope = processing.run("native:slope", {'INPUT': contourRaster,
                                        'Z_FACTOR':1,
                                        'OUTPUT': output_tif})
        slopeRaster = QgsRasterLayer(output_tif, 'elev_raster')
        provider = slopeRaster.dataProvider()

        slope_stats = provider.bandStatistics(1, QgsRasterBandStats.All)
        slope_max = slope_stats.maximumValue
        slope_min = slope_stats.minimumValue
        slope_range =  slope_stats.range
        
        ###################################################################
        aa_file = self.ActivityA_LEdit.text()
        aa_vec_file = QgsVectorLayer(str(aa_file), "Site layer", "ogr")

        #get the AA layer's EPSG code
        vector_crs = aa_vec_file.crs().authid()
        #get the AA layer's extent coordinates
        ext = aa_vec_file.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        #do this operation to get information
        clip_to_AA = processing.run("gdal:cliprasterbyextent", {'INPUT': slopeRaster,
                                                   'PROJWIN':'{xminimum},{xmaximum},{yminimum},{ymaximum} [{crs}]'.format(xminimum = xmin, xmaximum = xmax, yminimum = ymin, ymaximum = ymax, crs = vector_crs),
                                                   'OVERCRS':False,
                                                   'NODATA':None,
                                                   'OPTIONS':'COMPRESS=PACKBITS',
                                                   'DATA_TYPE':0,
                                                   'EXTRA':'',
                                                   'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
        
        AARaster = QgsRasterLayer(clip_to_AA, 'AAslope_raster')
        provider = AARaster.dataProvider()
        #get slope percent from spinbox
        slope_Value = self.slopeSpinBox.value()
        #get stats from raster of the activity area
        AA_stats = provider.bandStatistics(1, QgsRasterBandStats.All)
        AA_slope_min = AA_stats.minimumValue
        AA_slope_max = AA_stats.maximumValue
        AA_slope_range = AA_stats.range
    
        slope_percent_range = (slope_range/100) * slope_Value
        lower_value = AA_slope_min - slope_percent_range
        upper_value = AA_slope_max + slope_percent_range

        outputSlope_tif = '{output_path}/slope.tif'.format(output_path = path)
        #use information to preform calculations on entire raster
        processing.run("qgis:rastercalculator", {'EXPRESSION':'IF(("{firstLayer}@1" > {lower}) AND ("{secondLayer}@1" < {upper}), 5, 3)'.format(firstLayer = elevation_file_name, lower = lower_value, secondLayer = elevation_file_name, upper = upper_value),
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = elevation_file_name)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': outputSlope_tif})
        return

    def aspectFromElevation(self):
        #
        #get output path
        path = self.outputPathFileWidget.filePath()
        #this was the easiest, not necessarily the most efficient method
        #must vectorize the file path, not the new file name variable
        current_file = self.contourFileLEdit.text()
        v_contour_file = QgsVectorLayer(str(current_file), "Site layer", "ogr")
        elevation_field = self.elevationFieldCBox.currentText()
        #get the vector's EPSG code
        vector_crs = v_contour_file.crs().authid()
        #get the layer's extent coordinates
        ext = v_contour_file.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        #rasterize and save to memory with name specific to field rasterized
        #output_tif = '{output_path}/temp/new_++{file_name}.tif'.format(output_path = path, file_name = elevation_field)
        outputFile = 'aspect'
        elevationRaster = vectorToRasterProcessing = processing.run("gdal:rasterize", {'INPUT': v_contour_file,
                                          'FIELD':'{}'.format(elevation_field),
                                          'BURN':0,
                                          'USE_Z':False,
                                          'UNITS':0,
                                          'WIDTH':200,
                                          'HEIGHT':200,
                                          'EXTENT':'{xminimum},{xmaximum},{yminimum},{ymaximum} [{crs}]'.format(xminimum = xmin, xmaximum = xmax, yminimum = ymin, ymaximum = ymax, crs = vector_crs),
                                          'NODATA':0,
                                          'OPTIONS':'COMPRESS=PACKBITS',
                                          'DATA_TYPE':5,
                                          'INIT':None,
                                          'INVERT':False,
                                          'EXTRA':'',
                                          'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
        contourRaster = QgsRasterLayer(elevationRaster, 'elev_raster')
        ####################################
        outputAspect_tif = '{output_path}/temp/aspect.tif'.format(output_path = path)
        processing.run("native:aspect", {'INPUT': contourRaster,
                                        'Z_FACTOR':1,
                                        'OUTPUT': outputAspect_tif})
        Aspect = QgsRasterLayer(outputAspect_tif, 'aspect_raster')
        #create seperate raster for each aspect shosen, couldn't work out how to do it all in one
        aspects = self.aspectComboBox.checkedItems()
        print(aspects)
        if 'North' in aspects:
            NNW_outputAspect_tif = '{output_path}/NNW_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 337.5) AND ("aspect@1" < 360), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': NNW_outputAspect_tif})
        if 'North' in aspects:
            NNE_outputAspect_tif = '{output_path}/NNE_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 0.0) AND ("aspect@1" < 22.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': NNE_outputAspect_tif})
        if 'North-east' in aspects:
            NE_outputAspect_tif = '{output_path}/NE_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 22.5) AND ("aspect@1" < 67.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': NE_outputAspect_tif})
        if 'East' in aspects:
            E_outputAspect_tif = '{output_path}/E_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 67.5) AND ("aspect@1" < 112.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': E_outputAspect_tif})
        if 'South-east' in aspects:
            SE_outputAspect_tif = '{output_path}/SE_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 112.5) AND ("aspect@1" < 157.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': SE_outputAspect_tif})
        if 'South' in aspects:
            S_outputAspect_tif = '{output_path}/S_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 157.5) AND ("aspect@1" < 202.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': S_outputAspect_tif})
        if 'South-west' in aspects:
            SW_outputAspect_tif = '{output_path}/SW_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 202.5) AND ("aspect@1" < 247.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': SW_outputAspect_tif})
        if 'West' in aspects:
            W_outputAspect_tif = '{output_path}/W_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 247.5) AND ("aspect@1" < 292.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': W_outputAspect_tif})
        if 'North-west' in aspects:
            NW_outputAspect_tif = '{output_path}/NW_aspect.tif'.format(output_path = path)
            processing.run("qgis:rastercalculator", {'EXPRESSION': 'IF(("aspect@1" >= 292.5) AND ("aspect@1" < 337.5), 5, 3)',
                                                 'LAYERS':['{output_path}/temp/{layer}.tif'.format(output_path = path, layer = outputFile)],
                                                 'CELLSIZE':0,
                                                 'EXTENT':None,
                                                 'CRS':None,
                                                 'OUTPUT': NW_outputAspect_tif})
        else:
            pass
        
        return

    
    def createModel(self):
        #the code for implementing MaxEnt in python comes from a package 'elapid', written by Chris Anderson
        #details can be found in this article
        #Anderson2023,
        #title = {elapid: Species distribution modeling tools for Python}, journal = {Journal of Open Source Software}
        #author = {Christopher B. Anderson},
        #doi = {10.21105/joss.04930},
        #url = {https://doi.org/10.21105/joss.04930},
        #year = {2023},
        #publisher = {The Open Journal},
        #volume = {8},
        #number = {84},
        #pages = {4930},
        #These lists will be joined and form a csv containing model fit for each prediction
        sites_predicted_list = []
        predictive_value_list = []
        #get output path
        path = self.outputPathFileWidget.filePath()
        #create folder called temp inside the path chosen by user
        directory = 'predictions'
        pathForFolder = os.path.join(path, directory)
        accessPermissions = 0o777#readable and writeable by all
        os.mkdir(pathForFolder, accessPermissions)
        ###############################################################################
        raster_path = "{input_path}".format(input_path = path)
        site_point_vector = self.Site_L_Edit.text()
        site_type_field = self.siteFieldCBox.currentText()
        site_list = self.siteTypeCBox.checkedItems()
        ####################################################################
        #this routine looks in a folder and loads the tifs
        #it removes the need to know the name of the files or how many there are
        raster_names = []
        wildcard_path = "{input_path}\*.tif".format(input_path = path)
        files = glob.glob(wildcard_path)
        for file in files:
            fileAndExt = os.path.basename(file)
            raster_names.append(fileAndExt)
        ############################################################################
        sites_gdf = gpd.read_file(site_point_vector)
        sites_gdf.set_index("{}".format(site_type_field), inplace = True)
        #if multiple site types were chosen, they will be modelled individually.  If only one was chosen, no problem
        for site in site_list:
            unique_site_type = sites_gdf.loc[str(site)]
            if unique_site_type.shape[0] < 2:#there has to be a way to test if there are more than one
                pass
            else:
                rasters = [f"{raster_path}/{raster}" for raster in raster_names]
                labels = [raster[:] for raster in raster_names]

                #mapping preferences
                mpl.style.use('ggplot')
                warnings.filterwarnings("ignore")

                # read the presence data for each site type
                #this is the result of the loop initiated above
                presence = unique_site_type
                # sample raster pixel value under each point location for randomly placed points
                background = ela.sample_raster(rasters[0], count=10_000)

                # merge datasets and read the covariates at each point location
                merged = ela.stack_geodataframes(presence, background, add_class_label=True)
                annotated = ela.annotate(merged, rasters, drop_na=True, quiet=True)

                # split the x/y data
                x = annotated.drop(columns=['class', 'geometry'])
                y = annotated['class']

                # train the model
                model = ela.MaxentModel(transform='cloglog', beta_multiplier=2.0)
                model.fit(x, y)

                # evaluate quality of model
                ypred = model.predict(x)
                auc = metrics.roc_auc_score(y, ypred)
                presence_crs = presence.crs

                # write the model predictions to disk
                output_raster = '{output_path}\predictions\{site_type}.tif'.format(output_path = path, site_type = site)
                ela.apply_model_to_rasters(model, rasters, output_raster, quiet=True)

                ########################################
                ##############################################
                # Set figure size and title size of plots
                mpl.rcParams['figure.figsize'] = (14, 14)
                mpl.rcParams['axes.titlesize'] = 20

                # and read into memory
                src = rasterio.open(output_raster, 'r')

                #define the extents of the raster
                tiff_extent = [src.bounds[0], src.bounds[2], src.bounds[1], src.bounds[3]]

                # Plot uncropped array
                f, ax = plt.subplots()

                ax.set_title(f'Predictive model for {site}, fit: {auc:0.3f}')

                # use imshow so that we have something to map the colorbar to
                image_hidden = ax.imshow(src.read(1, masked=True), 
                                        extent=tiff_extent,#use the extents
                                        cmap='GnBu', 
                                        vmin= 0, 
                                        vmax= 1)

                rasterplot.show(
                    src.read(1, masked=True),  # use src.read(1) with your data
                    extent=tiff_extent,
                    cmap='GnBu',
                    ax=ax,

                )

                # add colorbar using the now hidden image as reference
                f.colorbar(image_hidden, ax=ax)

                presence.plot(ax=ax)
                plt.savefig('{output_path}\predictions\{site_type}.jpg'.format(output_path = path, site_type = site))#save to disk
                sites_predicted_list.append(site)
                predictive_value_list.append(auc)

            array = []
            index_values = []
            for i in range(len(sites_predicted_list)):
                array.append([sites_predicted_list[i], predictive_value_list[i]])
                index_values.append(i)

            columns_values = ['Site type', 'Confidence level']
            df = pd.DataFrame(data=array, index=index_values, columns=columns_values)
            df.to_csv('{output_path}/confidence_level.csv'.format(output_path = path))

        self.close()
        return
    
    def clearInputs(self):
        self.contourFileLEdit.clearValue()
        self.elevationFieldCBox.clear()

        self.ActivityA_LEdit.clearValue()
        self.Geo_Area_LEdit.clearValue()

        self.Site_L_Edit.clearValue()
        self.siteFieldCBox.clear()
        self.siteTypeCBox.clear()

        self.DefaultLineEdit1.clearValue()#this clears boxes filled with folder paths
        self.Default_CBox1.clear()
        self.Custom_T_Widget.clear()#clear table
        #uncheck both radio buttons, but first they have to be able to have the same state
        self.AAfeatures_RButton.setAutoExclusive(False)
        self.AAfeatures_RButton.setChecked(False)
        self.AAwArtefact_RButton.setChecked(False)
        return

    def addAspects(self):
        self.aspectComboBox.clear()
        list_aspects = ['North', 'North-east', 'East', 'South-east', 'South', 'South-west', 'West', 'North-west']
        for li in list_aspects:
            self.aspectComboBox.addItem(str(li))
        return